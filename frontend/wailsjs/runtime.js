// The Wails runtime.
// YOU SHOULD NOT NEED TO EDIT THIS FILE.
// This file is auto-generated by the Wails CLI at build time.
// If you need to edit this file, please follow the instructions at
// https://wails.io/docs/guides/runtime#manual-runtime

/* eslint-disable */

window.wails = window.wails || {};
window.wails.runtime = (function () {
  // The official Go function name for the EventsEmit method
  const EventsEmit = 'wails:FE:EventsEmit';
  // The official Go function name for the Call method
  const Call = 'wails:FE:Call';
  const BrowserOpenURL = 'wails:FE:BrowserOpenURL';

  const Log = 'wails:FE:Log';

  const go = {
    // We need to keep track of the salt
    salt: '',
    // This is the main call method for the Go side
    Call(method, args) {
      // Create a promise for the Go call
      return new Promise((resolve, reject) => {
        // We need a unique ID for each call
        const callID = crypto.randomUUID();
        // Set up the callback for the Go call
        window.wails.runtime.callbacks[callID] = (result, isError) => {
          if (isError) {
            reject(result);
          } else {
            resolve(result);
          }
          // Remove the callback
          delete window.wails.runtime.callbacks[callID];
        };
        // We need to send the salt with each call
        const salt = go.salt;
        // Call the Go side
        window.chrome.webview.postMessage({
          ID: Call,
          data: {
            callID,
            salt,
            method,
            args,
          },
        });
      });
    },
    // This is the main call method for the Go side
    Log(level, message, ...data) {
      window.chrome.webview.postMessage({
        ID: Log,
        data: {
          level,
          message,
          data: data.length > 0 ? JSON.stringify(data) : '',
        },
      });
    },

    // This is the main call method for the Go side
    BrowserOpenURL(url) {
      window.chrome.webview.postMessage({
        ID: BrowserOpenURL,
        data: url,
      });
    },

    // A simple event system for Go to send events to the frontend
    EventsOn(eventName, callback) {
      // Check if the event name is a string
      if (typeof eventName !== 'string' || eventName.length === 0) {
        go.Log('E', 'Event name must be a non-empty string');
        return () => {};
      }
      // Check if the callback is a function
      if (typeof callback !== 'function') {
        go.Log('E', 'Callback must be a function');
        return () => {};
      }
      // Add the event listener
      return addEventListener(eventName, callback);
    },

    EventsOnce(eventName, callback) {
      const onceCallback = (data) => {
        // Call the original callback
        callback(data);
        // Remove the event listener
        removeEventListener(eventName, onceCallback);
      };
      // Add the event listener
      return this.EventsOn(eventName, onceCallback);
    },

    EventsOnMultiple(eventName, callback, maxCallbacks) {
      // Check if the event name is a string
      if (typeof eventName !== 'string' || eventName.length === 0) {
        go.Log('E', 'Event name must be a non-empty string');
        return () => {};
      }
      // Check if the callback is a function
      if (typeof callback !== 'function') {
        go.Log('E', 'Callback must be a function');
        return () => {};
      }
      // Check if maxCallbacks is a number
      if (typeof maxCallbacks !== 'number' || maxCallbacks <= 0) {
        go.Log('E', 'maxCallbacks must be a positive number');
        return () => {};
      }

      const multiCallback = (data) => {
        // Call the original callback
        callback(data);
        // Decrement the number of callbacks
        maxCallbacks--;
        // If the max number of callbacks has been reached, remove the event listener
        if (maxCallbacks === 0) {
          removeEventListener(eventName, multiCallback);
        }
      };
      // Add the event listener
      return addEventListener(eventName, multiCallback);
    },

    EventsEmit,

    // Expose the callbacks to the global scope
    callbacks: {},
  };

  function addEventListener(eventName, callback) {
    // Create the event if it doesn't exist
    if (!window.wails.runtime.listeners[eventName]) {
      window.wails.runtime.listeners[eventName] = [];
    }
    // Add the callback to the event
    window.wails.runtime.listeners[eventName].push(callback);
    // Return the un-listener
    return () => {
      // Remove the callback from the event
      window.wails.runtime.listeners[eventName] = window.wails.runtime.listeners[eventName].filter(
        (cb) => cb !== callback,
      );
    };
  }

  function removeEventListener(eventName, callback) {
    // If the event doesn't exist, ignore the call
    if (!window.wails.runtime.listeners[eventName]) {
      return;
    }
    // Remove the callback from the event
    window.wails.runtime.listeners[eventName] = window.wails.runtime.listeners[eventName].filter((cb) => cb !== callback);
  }

  // Set up the event listeners
  function setup() {
    // Create the listeners map
    window.wails.runtime.listeners = {};
    // This is called by the Go side when an event is emitted
    window.wails.runtime.triggerEvent = function (eventName, data) {
      // Check if there are any listeners for this event
      if (window.wails.runtime.listeners[eventName]) {
        // Get the data
        // If the data is a string, parse it as JSON
        const eventData = typeof data === 'string' ? JSON.parse(data) : data;
        // Call each listener
        window.wails.runtime.listeners[eventName].forEach((callback) => {
          callback(eventData);
        });
      }
    };

    // This is called by the Go side when a call returns
    window.wails.runtime.invokeCallback = function (callID, result, isError) {
      // Check if there is a callback for this call
      if (window.wails.runtime.callbacks[callID]) {
        // Get the data
        // If the result is a string, parse it as JSON
        const callbackResult = typeof result === 'string' ? JSON.parse(result) : result;
        // Call the callback
        window.wails.runtime.callbacks[callID](callbackResult, isError);
      }
    };

    // This is called by the Go side when the salt is generated
    window.wails.runtime.setSalt = function (salt) {
      go.salt = salt;
    };
  }

  // Set up the runtime
  setup();

  // Return the go object
  return go;
})();
